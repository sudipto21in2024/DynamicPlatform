# Dry Run: Building an Address Management System

This document simulates the end-to-end flow of building a simple **Address Management System** using the Platform specifications. It validates the architecture by tracing a real use case from "Drag-and-Drop" to "Running Code".

## 1. The Requirement (User Story)
The customer wants a system to manage Users and their multiple Addresses.
*   **Entities**: `User` (Name, Email), `Address` (Street, City, Zip, UserID).
*   **Relation**: One User has Many Addresses.
*   **Logic**: Zip Code must be 5 digits.
*   **UI**: A Dashboard to list Users and a Form to add Addresses.

---

## 2. Phase 1: The Design (Visual Studio)

### 2.1 User Actions
1.  User opens "Data Designer".
2.  Creates Entity `User`. Adds field `Email` (String).
3.  Creates Entity `Address`. Adds field `ZipCode` (String).
4.  Draws a line from `User` to `Address`. Selects "One-to-Many".
5.  Opens "Page Designer". Drags a "Table" widget onto the canvas and binds it to `User`.

### 2.2 The Resulting Metadata (Internal JSON)
The Platform API saves this JSON to the `Artifacts` table.

**Artifact: Module_Core.json**
```json
{
  "entities": [
    {
      "id": "e_user",
      "name": "User",
      "fields": [
        { "name": "Id", "type": "Guid", "isKey": true },
        { "name": "Email", "type": "String", "maxLength": 100 }
      ]
    },
    {
      "id": "e_address",
      "name": "Address",
      "fields": [
        { "name": "Id", "type": "Guid", "isKey": true },
        { "name": "Street", "type": "String" },
        { "name": "ZipCode", "type": "String" },
        { "name": "UserId", "type": "Guid", "isForeignKey": true } // Generated by Relation
      ]
    }
  ],
  "relationships": [
    {
      "from": "User",
      "to": "Address",
      "type": "OneToMany",
      "foreignKey": "UserId"
    }
  ]
}
```

---

## 3. Phase 2: Compilation ( The Engine)
The user clicks **"Publish"**. The `Platform.Engine` starts.

### Step 2.1: Validation
*   Engine checks: "Does `UserId` exist in Address?" -> Yes.
*   Engine checks: "Is ZipCode type compatible?" -> Yes.

### Step 2.2: Context Building
The Normalizer transforms the JSON into a "Template Model" for C#.
*   `User` entity becomes `public partial class User`.
*   Relation becomes `public virtual ICollection<Address> Addresses { get; set; }`.

### Step 2.3: Rendering (Templates)
The Engine loads `Templates/Backend/Entity.scriban`.

**Input (Scriban Context):**
```json
{ "className": "User", "namespace": "MyCustomerApp.Domain" }
```

**Template:**
```csharp
namespace {{ namespace }};
public partial class {{ className }} { ... }
```

---

## 4. Phase 3: The Generated Code (Output)

The platform writes these files to the `/src/generated` folder on the disk.

### 4.1 Backend Entities
**File:** `Domain/Entities/User.Generated.cs`
```csharp
// <auto-generated>
using System;
using System.ComponentModel.DataAnnotations;

namespace AdressApp.Domain.Entities
{
    public partial class User
    {
        [Key]
        public Guid Id { get; set; }
        public string Email { get; set; }

        // Navigation Property from Relation
        public virtual ICollection<Address> Addresses { get; set; }
    }
}
```

**File:** `Domain/Entities/Address.Generated.cs`
```csharp
// <auto-generated>
namespace AdressApp.Domain.Entities
{
    public partial class Address
    {
        [Key]
        public Guid Id { get; set; }
        public string ZipCode { get; set; }
        public Guid UserId { get; set; }
        
        [ForeignKey("UserId")]
        public virtual User User { get; set; }
    }
}
```

### 4.2 Backend API
**File:** `Controllers/UsersController.Generated.cs`
```csharp
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly IRepository<User> _repo;

    public UsersController(IRepository<User> repo) { _repo = repo; }

    [HttpGet]
    public async Task<IActionResult> GetAll() 
    {
        return Ok(await _repo.GetAllAsync());
    }
}
```

### 4.3 Frontend Component (Angular)
**File:** `src/app/pages/user-list/user-list.generated.component.ts`
```typescript
@Component({ template: '' })
export abstract class UserListGeneratedComponent implements OnInit {
    users: UserDto[] = [];
    
    constructor(protected userService: UserService) {}

    ngOnInit() {
        this.userService.getAll().subscribe(data => this.users = data);
    }
}
```

---

## 5. Phase 4: Customization (The "Low-Code" Part)

The requirement was: **"Zip Code must be 5 digits."**
The generated code doesn't know this rule. The developer adds custom logic *without touching generated files*.

### Action:
Developer creates: `Domain/Entities/Address.Custom.cs` (Note: **Not** Generated.cs)

```csharp
using System.ComponentModel.DataAnnotations;

namespace AdressApp.Domain.Entities
{
    // Extends the partial class
    public partial class Address : IValidatableObject
    {
        public IEnumerable<ValidationResult> Validate(ValidationContext context)
        {
            if (ZipCode.Length != 5)
            {
                yield return new ValidationResult("Zip must be 5 digits");
            }
        }
    }
}
```

### Result:
*   When `UsersController` calls `_repo.Save(address)`, EF Core triggers `Validate()`.
*   If invalid, it throws an exception.
*   API returns `400 Bad Request`.
*   **The generated code remains checking basic types, custom code handles rules.**

---

## 6. Phase 5: Runtime Execution

1.  **Deployment**: The simulated CI/CD pipeline runs `dotnet build`.
2.  **Compilation**: The C# compiler merges `Address.Generated.cs` and `Address.Custom.cs` into a single binary class.
3.  **Migration**: The app starts. `EnsureCreated()` runs. SQL Tables `Users` and `Addresses` are created.
4.  **Usage**:
    *   End-User opens Browser.
    *   Angular App fetches `GET /api/users`.
    *   Controller hits DB.
    *   JSON returns.
    *   User sees list.
